# T3批次2会议产出物

## 文档信息

**文档版本**: v1.0
**创建日期**: 2026-01-20
**会议批次**: 批次2 - 技术架构方案讨论
**会议时间**: 2026-01-20 10:30-12:00
**参与人员**: 后端架构师、前端架构师、性能专家、技术规划分析师

---

## 1. 数据同步架构设计

### 1.1 同步协议选择

**决策**: 采用 **WebSocket + HTTP降级** 方案

**选择理由**:
- 后端已集成 `@fastify/websocket` 插件,无需额外依赖
- 实时同步是核心需求,延迟要求 <500ms
- HTTP 降级确保兼容性和稳定性
- 离线数据同步使用批量 HTTP POST

**降级策略**:

```typescript
interface FallbackStrategy {
  conditions: [
    'WebSocket连接失败',
    'WebSocket连接超时(>5秒)',
    'WebSocket连接频繁断开(1分钟内>3次)'
  ];
  action: '自动切换到HTTP轮询模式';
  pollingIntervals: {
    normal: 5;      // 秒
    highPriority: 1; // 秒
  };
  reconnectInterval: 30; // 秒
}
```

**连接管理机制**:

| 生命周期 | 动作 | 参数 |
|---------|------|------|
| 建立连接 | 验证JWT → 心跳检测 | 心跳间隔: 30秒 |
| 断开检测 | 自动重连 | 指数退避: 1s, 2s, 4s, 8s, 30s |
| 连接池管理 | 每设备最多1个活跃连接 | 超时清理: 60秒 |

---

### 1.2 同步数据格式设计

**数据格式选择**: JSON

**理由**:
- 可读性好,便于调试
- 通用性强,跨平台兼容
- 与现有 API 格式一致
- 性能可接受(后续可优化)

**同步消息格式**:

```typescript
interface SyncRequest {
  userId: number;
  deviceId: string;
  timestamp: number;
  operations: SyncOperation[];
}

interface SyncOperation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: 'note' | 'folder' | 'review';
  entityId: number;
  data: any;
  timestamp: number;
  version: number;
  contentHash: string;
}

interface SyncResponse {
  success: boolean;
  data: {
    operations: SyncOperation[];
    conflicts: Conflict[];
    timestamp: number;
  };
  error?: string;
}

interface Conflict {
  id: string;
  type: 'note' | 'folder' | 'review';
  entityId: number;
  localVersion: any;
  remoteVersion: any;
  localTimestamp: number;
  remoteTimestamp: number;
  resolved: boolean;
}

interface WebSocketEvent = 
  | { type: 'note:created'; data: Note }
  | { type: 'note:updated'; data: Note }
  | { type: 'note:deleted'; data: { id: number } }
  | { type: 'review:created'; data: Review }
  | { type: 'review:updated'; data: Review }
  | { type: 'review:deleted'; data: { id: number } }
  | { type: 'folder:created'; data: Folder }
  | { type: 'folder:updated'; data: Folder }
  | { type: 'folder:deleted'; data: { id: number } }
  | { type: 'sync:started'; data: { timestamp: number } }
  | { type: 'sync:completed'; data: { timestamp: number; count: number } }
  | { type: 'sync:failed'; data: { error: string; timestamp: number } }
  | { type: 'conflict:detected'; data: Conflict };
```

**版本控制机制**:
- 基于 `version` 字段递增
- 基于 `contentHash` 检测内容变更
- 基于 `timestamp` 确定操作顺序

---

### 1.3 同步频率控制

**同步策略**:

| 策略 | 触发条件 | 频率 | 用途 |
|------|---------|------|------|
| 实时同步 | 用户主动操作 | 即时(<500ms) | 高优先级数据 |
| 定时同步 | 每5分钟 | 5分钟 | 常规数据同步 |
| 手动同步 | 用户触发 | 按需 | 用户主动请求 |
| 批量同步 | 离线数据上传 | 恢复连接时 | 离线数据同步 |

**同步优先级**:

| 优先级 | 场景 | 说明 |
|--------|------|------|
| 高 | 用户主动操作 | 立即同步 |
| 中 | 定时同步 | 5分钟一次 |
| 低 | 后台同步 | 空闲时执行 |

---

### 1.4 冲突检测和解决算法

**冲突检测**:

```typescript
interface ConflictDetection {
  methods: [
    '基于时间戳的版本检测',
    '基于内容哈希的变更检测',
    '基于操作日志的冲突识别'
  ];
  algorithm: `
    IF local.version != remote.version THEN
      IF local.contentHash != remote.contentHash THEN
        检测到冲突
      END IF
    END IF
  `;
}
```

**冲突解决策略**:

| 策略 | 优先级 | 说明 |
|------|--------|------|
| 最后修改优先 | 默认 | 自动选择最后修改的版本 |
| 用户选择 | P0 | 展示冲突,让用户选择 |
| 手动合并 | P1 | 提供合并界面,用户手动合并 |
| 服务器优先 | 备用 | 服务器版本覆盖本地版本 |

**冲突解决流程**:

```
1. 检测到冲突
   ↓
2. 暂停同步
   ↓
3. 通知用户 (推送通知 + UI提示)
   ↓
4. 用户选择解决策略
   ├─ 选择本地版本 → 应用 → 标记已解决
   ├─ 选择远程版本 → 应用 → 标记已解决
   └─ 手动合并 → 合并界面 → 应用 → 标记已解决
   ↓
5. 恢复同步
```

---

## 2. 前端本地缓存方案

### 2.1 缓存技术选择

**决策**: 采用 **混合缓存方案**

**缓存分层设计**:

| 层级 | 技术 | 存储容量 | 持久化 | 响应时间 | 使用场景 |
|------|------|----------|--------|----------|----------|
| L1 | Memory Cache | ~10MB | 会话 | <1ms | 当前会话热点数据 |
| L2 | IndexedDB | ~500MB | 永久 | 5-10ms | 大量离线数据(笔记、复盘) |
| L3 | localStorage | ~5MB | 永久 | <1ms | 用户设置、认证信息 |

**技术栈**:
- IndexedDB: 原生 API + 简单封装
- localStorage: 原生 API + 简单封装
- 不引入第三方缓存库,减少依赖复杂度

**缓存数据迁移策略**:

```typescript
const CACHE_VERSION = '1.0';

async function migrateCache() {
  const currentVersion = localStorage.getItem('cache_version');
  
  if (!currentVersion) {
    await initCache();
  } else if (currentVersion !== CACHE_VERSION) {
    await clearCache();
    await initCache();
  }
}
```

---

### 2.2 缓存数据结构设计

**核心数据模型**:

```typescript
const CacheKeys = {
  USER: 'user',
  USER_SETTINGS: 'user:settings',
  NOTES: 'notes',
  NOTE: (id: number) => `note:${id}`,
  NOTES_BY_FOLDER: (folderId: number) => `folder:${folderId}:notes`,
  PINNED_NOTES: 'notes:pinned',
  FOLDERS: 'folders',
  FOLDER: (id: number) => `folder:${id}`,
  REVIEWS: 'reviews',
  REVIEW: (id: number) => `review:${id}`,
  REVIEWS_BY_DATE: (date: string) => `reviews:date:${date}`,
  SYNC_QUEUE: 'sync:queue',
  SYNC_STATUS: 'sync:status',
  SYNC_CONFLICTS: 'sync:conflicts',
  OFFLINE_EDITS: 'offline:edits',
  OFFLINE_CHANGES: 'offline:changes',
} as const;

interface CacheData<T> {
  data: T;
  timestamp: number;
  version: number;
  hash: string;
  expiresAt?: number;
}

interface SyncQueueItem {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: 'note' | 'folder' | 'review';
  entityId: number;
  data: any;
  timestamp: number;
  retryCount: number;
  status: 'pending' | 'syncing' | 'failed' | 'resolved';
  errorMessage?: string;
}

interface SyncStatus {
  lastSyncTime: number;
  isSyncing: boolean;
  pendingItems: number;
  failedItems: number;
  conflictItems: number;
  syncMode: 'realtime' | 'offline' | 'polling';
  connectionStatus: 'connected' | 'disconnected' | 'reconnecting';
}

interface Conflict {
  id: string;
  type: 'note' | 'folder' | 'review';
  entityId: number;
  localVersion: any;
  remoteVersion: any;
  localTimestamp: number;
  remoteTimestamp: number;
  resolved: boolean;
  resolution?: 'local' | 'remote' | 'merge';
}

interface UserSettings {
  theme: 'light' | 'dark' | 'auto';
  fontSize: 'small' | 'medium' | 'large';
  autoSave: boolean;
  autoSaveInterval: number;
  syncEnabled: boolean;
  offlineMode: boolean;
}

interface AuthInfo {
  userId: number;
  token: string;
  deviceId: string;
  expiresAt: number;
}
```

**IndexedDB 数据库结构**:

```typescript
const DB_NAME = 'WebNoteCache';
const DB_VERSION = 1;

interface DatabaseSchema {
  notes: {
    keyPath: 'id';
    indexes: [
      { name: 'user_id', keyPath: 'user_id' },
      { name: 'folder_id', keyPath: 'folder_id' },
      { name: 'updated_at', keyPath: 'updated_at' },
      { name: 'user_folder', keyPath: ['user_id', 'folder_id'] }
    ];
  };
  folders: {
    keyPath: 'id';
    indexes: [
      { name: 'user_id', keyPath: 'user_id' },
      { name: 'updated_at', keyPath: 'updated_at' }
    ];
  };
  reviews: {
    keyPath: 'id';
    indexes: [
      { name: 'user_id', keyPath: 'user_id' },
      { name: 'date', keyPath: 'date' },
      { name: 'user_date', keyPath: ['user_id', 'date'] }
    ];
  };
  syncQueue: {
    keyPath: 'id';
    indexes: [
      { name: 'status', keyPath: 'status' },
      { name: 'timestamp', keyPath: 'timestamp' },
      { name: 'status_timestamp', keyPath: ['status', 'timestamp'] }
    ];
  };
  conflicts: {
    keyPath: 'id';
    indexes: [
      { name: 'resolved', keyPath: 'resolved' },
      { name: 'timestamp', keyPath: 'timestamp' }
    ];
  };
}
```

---

### 2.3 缓存更新策略

**更新策略**: 写透 + 失效策略

**详细策略**:

```typescript
interface CacheUpdateStrategy {
  writeThrough: [
    '用户编辑笔记 → 更新本地缓存 + 发送到服务器',
    '用户创建笔记 → 写入本地缓存 + 发送到服务器',
    '用户删除笔记 → 删除本地缓存 + 发送到服务器'
  ];
  
  writeBack: [
    '离线编辑 → 只更新本地缓存 + 加入同步队列',
    '网络恢复 → 批量同步到服务器'
  ];
  
  invalidate: [
    {
      type: '时间失效',
      rules: [
        '默认TTL: 1小时',
        '笔记内容: 30分钟',
        '用户设置: 24小时'
      ]
    },
    {
      type: '版本失效',
      rules: [
        '服务器推送数据更新时,使对应缓存失效',
        '版本号不匹配时,重新从服务器获取'
      ]
    },
    {
      type: '手动失效',
      rules: [
        '用户点击"刷新"按钮',
        '用户手动同步'
      ]
    },
    {
      type: '空间失效',
      rules: [
        'IndexedDB容量超过400MB时,清理最久未使用的数据',
        '使用LRU策略'
      ]
    }
  ];
  
  preload: [
    '应用启动时,预加载热点数据',
    '最近访问的10条笔记',
    '最近7天的复盘记录',
    '所有文件夹结构'
  ];
}
```

---

## 3. 数据库优化方案

### 3.1 现有数据库性能分析

**当前数据库架构**:
- 数据库: PostgreSQL
- ORM: Prisma
- Schema: User, Note, Folder, Review

**性能分析重点**:

| 查询类型 | 预期瓶颈 | 优化方向 |
|---------|---------|---------|
| 笔记列表查询 | WHERE user_id = ? ORDER BY updated_at DESC | 添加复合索引 |
| 按文件夹筛选 | WHERE user_id = ? AND folder_id = ? | 添加复合索引 |
| 置顶笔记查询 | WHERE user_id = ? AND is_pinned = true | 添加复合索引 |
| 复盘记录查询 | WHERE user_id = ? AND date = ? | 添加复合索引 |
| 笔记标题搜索 | WHERE title LIKE '%?%' | 使用全文搜索 |

---

### 3.2 索引优化方案

**新增索引规划**:

| 表名 | 索引字段 | 索引类型 | 说明 | 优先级 |
|------|----------|----------|------|--------|
| Note | (user_id, updated_at DESC) | B-tree | 用户笔记列表查询 | P0 |
| Note | (user_id, folder_id, updated_at DESC) | B-tree | 按文件夹查询笔记 | P0 |
| Note | (user_id, is_pinned, updated_at DESC) | B-tree | 置顶笔记查询 | P0 |
| Note | (title) | B-tree | 笔记标题搜索 | P1 |
| Note | (content) | GIN | 全文搜索索引 | P1 |
| Note | (user_id, content_hash) | B-tree | 冲突检测 | P0 |
| Review | (user_id, date DESC) | B-tree | 复盘记录查询 | P0 |
| Review | (user_id, mood, date DESC) | B-tree | 情绪分析查询 | P2 |
| Review | (content) | GIN | 全文搜索索引 | P1 |
| Folder | (user_id, updated_at DESC) | B-tree | 文件夹查询 | P0 |

**Prisma Schema 更新**:

```prisma
model Note {
  id              Int       @id @default(autoincrement())
  user_id         Int
  title           String
  content         String
  folder_id       Int?
  is_pinned       Boolean   @default(false)
  last_accessed_at DateTime  @updatedAt
  content_hash    String?
  created_at      DateTime  @default(now())
  updated_at      DateTime  @updatedAt
  
  user            User      @relation(fields: [user_id], references: [id])
  folder          Folder?   @relation(fields: [folder_id], references: [id])
  
  @@index([user_id, updated_at(sort: Desc)], name: "idx_note_user_updated")
  @@index([user_id, folder_id, updated_at(sort: Desc)], name: "idx_note_user_folder_updated")
  @@index([user_id, is_pinned, updated_at(sort: Desc)], name: "idx_note_user_pinned")
  @@index([title], name: "idx_note_title")
  @@index([content], type: Gin, name: "idx_note_content")
  @@index([user_id, content_hash], name: "idx_note_user_hash")
}

model Folder {
  id        Int      @id @default(autoincrement())
  user_id   Int
  name      String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  user      User      @relation(fields: [user_id], references: [id])
  notes     Note[]
  
  @@index([user_id, updated_at(sort: Desc)], name: "idx_folder_user_updated")
}

model Review {
  id           Int       @id @default(autoincrement())
  user_id      Int
  date         DateTime
  content      String
  mood         Int?
  achievements Json?
  improvements Json?
  plans        Json?
  template_id  Int?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
  
  user         User      @relation(fields: [user_id], references: [id])
  
  @@index([user_id, date(sort: Desc)], name: "idx_review_user_date")
  @@index([user_id, mood, date(sort: Desc)], name: "idx_review_user_mood_date")
  @@index([content], type: Gin, name: "idx_review_content")
}
```

**索引维护策略**:

```sql
-- 定期重建索引 (每月一次)
REINDEX INDEX CONCURRENTLY idx_note_user_updated;
REINDEX INDEX CONCURRENTLY idx_note_user_folder_updated;

-- 定期清理死元组 (每周一次)
VACUUM ANALYZE;
```

---

### 3.3 查询优化方案

**优化策略**:

1. **避免 N+1 查询**
   - 使用 Prisma 的 `include` 或 `select` 预加载关联数据
   - 批量查询替代循环查询

2. **使用分页**
   - 列表查询使用 `take` 和 `skip` 分页
   - 默认每页 20 条,最大 100 条

3. **使用索引**
   - 确保 WHERE、ORDER BY、JOIN 条件使用索引
   - 避免 SELECT *,只查询需要的字段

4. **优化 SQL 语句**
   - 使用 `WHERE` 替代 `HAVING`
   - 避免 `LIKE '%keyword%'` (使用全文搜索)
   - 使用 `IN` 替代多个 `OR`

5. **使用缓存**
   - 缓存热点数据(用户设置、文件夹结构)
   - 使用 Redis 缓存查询结果(可选,后续优化)

**示例优化**:

```typescript
// ❌ N+1 查询
const notes = await prisma.note.findMany({ where: { user_id } });
for (const note of notes) {
  const folder = await prisma.folder.findUnique({ where: { id: note.folder_id } });
  note.folder = folder;
}

// ✅ 预加载关联数据
const notes = await prisma.note.findMany({
  where: { user_id },
  include: { folder: true },
  orderBy: { updated_at: 'desc' },
  take: 20,
});

// ✅ 使用索引查询
const pinnedNotes = await prisma.note.findMany({
  where: { 
    user_id, 
    is_pinned: true 
  },
  orderBy: { updated_at: 'desc' },
});

// ✅ 分页查询
const page = 1;
const pageSize = 20;
const notes = await prisma.note.findMany({
  where: { user_id },
  orderBy: { updated_at: 'desc' },
  take: pageSize,
  skip: (page - 1) * pageSize,
});
```

---

## 4. 数据备份方案

### 4.1 备份策略设计

**备份类型与策略**:

| 备份类型 | 执行频率 | 执行时间 | 保留时长 | 说明 |
|---------|---------|---------|---------|------|
| 增量备份 | 每日 | 凌晨 02:00 | 7天 | 备份当日变更数据 |
| 全量备份 | 每周 | 周日 03:00 | 4周 | 备份完整数据库 |
| 月度备份 | 每月 | 每月1日 04:00 | 12个月 | 长期归档备份 |
| 手动备份 | 用户触发 | 实时 | 按需 | 用户主动备份 |

**备份服务设计**:

```typescript
class BackupService {
  private prisma: PrismaClient;
  private storage: BackupStorage;

  async fullBackup(): Promise<BackupResult> {
    const timestamp = new Date();
    const backupId = `full-${timestamp.getTime()}`;
    
    const dump = await this.dumpDatabase();
    const compressed = await this.compress(dump);
    const url = await this.storage.upload(backupId, compressed);
    
    await this.saveBackupMetadata({
      id: backupId,
      type: 'full',
      size: compressed.size,
      url,
      createdAt: timestamp,
    });
    
    return { success: true, backupId, url };
  }

  async incrementalBackup(): Promise<BackupResult> {
    const timestamp = new Date();
    const lastBackup = await this.getLastBackupTime();
    
    const changes = await this.queryChanges(lastBackup);
    const dump = JSON.stringify(changes);
    
    const backupId = `incremental-${timestamp.getTime()}`;
    const url = await this.storage.upload(backupId, dump);
    
    await this.saveBackupMetadata({
      id: backupId,
      type: 'incremental',
      size: dump.length,
      url,
      createdAt: timestamp,
      basedOn: lastBackup,
    });
    
    return { success: true, backupId, url };
  }

  async manualBackup(userId: number): Promise<BackupResult> {
    const userData = await this.dumpUserData(userId);
    const encrypted = await this.encrypt(userData);
    
    const backupId = `manual-${userId}-${Date.now()}`;
    const url = await this.storage.upload(backupId, encrypted);
    
    return { success: true, backupId, url };
  }

  async restore(backupId: string, targetUserId?: number): Promise<RestoreResult> {
    const backup = await this.storage.download(backupId);
    const decrypted = await this.decrypt(backup);
    await this.restoreDatabase(decrypted, targetUserId);
    
    return { success: true, restoredRecords: decrypted.recordCount };
  }
}
```

**备份元数据管理**:

```prisma
model Backup {
  id            String   @id @default(cuid())
  type          String   // 'full' | 'incremental' | 'manual'
  size          BigInt
  url           String
  status        String   @default('completed')
  created_at    DateTime @default(now())
  based_on      String?
  created_by    Int?
  
  @@index([type, created_at], name: "idx_backup_type_created")
  @@index([created_by, created_at], name: "idx_backup_user_created")
}
```

---

### 4.2 备份存储位置

**存储方案决策**: 选择 **阿里云 OSS**

**选择理由**:
- 国内访问速度快,延迟低
- 成本低廉,性价比高
- 与现有技术栈兼容性好
- 提供完善的 SDK 和 API

**云服务对比**:

| 云服务 | 优势 | 劣势 | 成本 | 推荐度 |
|--------|------|------|------|--------|
| AWS S3 | 成熟稳定、功能丰富 | 国内访问慢 | 中等 | ⭐⭐⭐ |
| 阿里云 OSS | 国内访问快、性价比高 | 国际支持弱 | 低 | ⭐⭐⭐⭐⭐ |
| 腾讯云 COS | 国内访问快、功能丰富 | 文档略少 | 低 | ⭐⭐⭐⭐ |

**存储配置**:

```typescript
import OSS from 'ali-oss';

const ossClient = new OSS({
  region: process.env.OSS_REGION || 'oss-cn-hangzhou',
  accessKeyId: process.env.OSS_ACCESS_KEY_ID!,
  accessKeySecret: process.env.OSS_ACCESS_KEY_SECRET!,
  bucket: process.env.OSS_BUCKET!,
});

class BackupStorage {
  async upload(backupId: string, data: Buffer): Promise<string> {
    const key = `webnote-backups/${backupId}`;
    
    await ossClient.put(key, data, {
      headers: {
        'Content-Type': 'application/octet-stream',
        'x-oss-server-side-encryption': 'AES256',
      },
    });
    
    return `https://${process.env.OSS_BUCKET}.${process.env.OSS_REGION}.aliyuncs.com/${key}`;
  }

  async download(backupId: string): Promise<Buffer> {
    const key = `webnote-backups/${backupId}`;
    const result = await ossClient.get(key);
    return result.content;
  }
}
```

**备份清理策略**:

```typescript
async cleanupOldBackups(): Promise<void> {
  const now = new Date();
  
  const incrementalCutoff = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  await prisma.backup.deleteMany({
    where: {
      type: 'incremental',
      created_at: { lt: incrementalCutoff },
    },
  });
  
  const fullCutoff = new Date(now.getTime() - 4 * 7 * 24 * 60 * 60 * 1000);
  const fullBackups = await prisma.backup.findMany({
    where: {
      type: 'full',
      created_at: { lt: fullCutoff },
    },
  });
  
  for (const backup of fullBackups) {
    const date = backup.created_at;
    if (date.getDate() <= 7 && date.getDay() === 0) {
      continue;
    }
    await prisma.backup.delete({ where: { id: backup.id } });
  }
}
```

---

## 5. 技术方案可行性评估

### 5.1 技术风险分析

| 风险ID | 风险描述 | 影响程度 | 可能性 | 应对策略 | 责任人 |
|--------|----------|----------|--------|----------|--------|
| T3-R1 | WebSocket连接不稳定导致同步失败 | 高 | 中 | 实现HTTP降级机制,自动重连 | 后端架构师 |
| T3-R2 | 前端缓存策略不合理导致数据不一致 | 高 | 中 | 充分的单元测试和集成测试 | 前端架构师 |
| T3-R3 | 数据库索引优化效果不明显 | 中 | 低 | 先进行性能分析,识别瓶颈,再针对性优化 | 性能专家 |
| T3-R4 | IndexedDB容量限制导致缓存失败 | 中 | 低 | 实现LRU清理策略,监控容量使用 | 前端架构师 |
| T3-R5 | 云存储成本超预期 | 低 | 低 | 定期监控存储使用,设置容量告警 | 后端架构师 |

### 5.2 技术依赖清单

| 依赖项 | 类型 | 版本 | 用途 | 优先级 |
|--------|------|------|------|--------|
| @fastify/websocket | 后端 | ^5.0.0 | WebSocket支持 | P0 |
| Prisma | 后端 | ^5.4.0 | ORM | P0 |
| PostgreSQL | 数据库 | - | 数据库 | P0 |
| 阿里云 OSS SDK | 后端 | ^6.0.0 | 云存储 | P0 |
| IndexedDB API | 前端 | - | 本地存储 | P0 |
| localStorage API | 前端 | - | 本地存储 | P0 |

### 5.3 实施建议

1. **分阶段实施**:
   - Phase 1: 数据库索引优化 + IndexedDB缓存
   - Phase 2: WebSocket连接 + 同步API
   - Phase 3: 冲突解决 + 同步UI
   - Phase 4: 备份功能 + 数据恢复

2. **测试优先**:
   - 每个功能完成后立即进行单元测试
   - 关键功能进行集成测试
   - 完整流程进行E2E测试

3. **性能监控**:
   - 同步延迟监控
   - 数据库查询性能监控
   - 缓存命中率监控
   - 存储使用量监控

---

## 6. 关键决策回顾

### 决策1: 同步协议选择
- 选择 WebSocket + HTTP降级方案
- 理由: 已有基础设施,满足实时性要求,降级确保稳定性

### 决策2: 缓存技术选择
- 选择混合缓存方案
- 理由: 分层设计兼顾性能和容量,不引入额外依赖

### 决策3: 数据库优化方案
- 添加10个索引,覆盖主要查询场景
- 理由: 针对性优化,提升查询性能

### 决策4: 备份存储选择
- 选择阿里云 OSS
- 理由: 国内访问快,成本低,兼容性好

### 决策5: 备份策略
- 增量备份(每日) + 全量备份(每周) + 手动备份
- 理由: 平衡备份频率和存储成本

---

## 7. 批次2会后行动项

| 任务 | 负责人 | 截止时间 | 优先级 |
|------|--------|----------|--------|
| 整理技术架构文档 | 后端架构师、前端架构师 | 批次2结束后24小时内 | P0 |
| 编写技术方案可行性评估报告 | 技术规划分析师 | 批次2结束后24小时内 | P0 |
| 更新Prisma Schema添加索引 | 后端架构师 | 批次3开始前 | P0 |
| 准备前后端API接口设计文档 | 后端架构师、前端架构师 | 批次3开始前 | P0 |

---

**文档编制**: 会议记录人
**文档审核**: 项目负责人
**文档批准**: 项目负责人
**最后更新**: 2026-01-20
