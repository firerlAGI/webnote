# T3批次3会议产出物

## 文档信息

**文档版本**: v1.0
**创建日期**: 2026-01-10
**会议批次**: 批次3 - 前后端技术细节设计
**会议时间**: 2026-01-10 14:00-15:15
**参与人员**: 后端架构师、前端架构师

---

## 1. 后端同步API接口设计

### 1.1 接口概览

| 接口 | 方法 | 路径 | 说明 | 优先级 |
|------|------|------|------|--------|
| WebSocket连接 | WS | /api/sync/connect | 建立WebSocket连接 | P0 |
| 同步笔记 | POST | /api/sync/notes | 批量同步笔记数据 | P0 |
| 同步复盘 | POST | /api/sync/reviews | 批量同步复盘记录 | P0 |
| 同步文件夹 | POST | /api/sync/folders | 批量同步文件夹数据 | P0 |
| 获取同步状态 | GET | /api/sync/status | 获取当前同步状态 | P1 |
| 获取同步队列 | GET | /api/sync/queue | 获取同步队列项列表 | P1 |
| 删除队列项 | DELETE | /api/sync/queue/:id | 删除指定的同步队列项 | P1 |
| 解决同步冲突 | POST | /api/sync/resolve | 解决数据同步冲突 | P0 |
| 获取数据差异 | POST | /api/sync/diff | 获取本地与远程数据的差异 | P2 |

### 1.2 WebSocket连接管理

**连接参数**:

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `token` | string | 是 | JWT认证令牌 |
| `deviceId` | string | 是 | 设备唯一标识 |
| `version` | string | 是 | 客户端版本 |

**握手验证流程**:
```
客户端建立连接 → 验证JWT有效性 → 检查设备连接状态 → 记录连接信息 → 发送连接成功消息 → 开始心跳检测
```

**心跳机制**:
- 心跳间隔: 客户端每30秒发送一次ping消息
- 超时判定: 服务器60秒未收到心跳则判定连接超时
- 自动重连: 客户端断开后自动重连,使用指数退避策略(1s, 2s, 4s, 8s, 30s)

**连接限制**:
- 每用户最多1个活跃连接
- 每设备最多1个活跃连接
- 超时清理: 60秒无活动自动清理

### 1.3 同步操作接口设计

**同步笔记接口** (`/api/sync/notes`):

请求体结构:
```typescript
interface SyncNotesRequest {
  operations: {
    type: 'create' | 'update' | 'delete';
    noteId?: number;
    data?: NoteData;
    timestamp: number;
    version: number;
    contentHash: string;
  }[];
  since?: number;
  options?: {
    autoResolve?: boolean;
    resolutionStrategy?: 'local' | 'remote' | 'latest';
    batchSize?: number;
  };
}
```

响应结构:
```typescript
interface SyncNotesResponse {
  success: true;
  data: {
    remoteOperations: {
      type: 'create' | 'update' | 'delete';
      note: NoteData;
      timestamp: number;
    }[];
    conflicts: Conflict[];
    stats: {
      uploaded: number;
      downloaded: number;
      conflicts: number;
      resolved: number;
    };
    timestamp: number;
    nextSyncAt: number;
  };
}
```

**同步复盘接口** (`/api/sync/reviews`):
- 请求结构与同步笔记类似
- 复盘数据包含: content, mood, achievements, improvements, plans
- 批量限制: 每次最多同步50条操作

**同步文件夹接口** (`/api/sync/folders`):
- 支持级联删除选项
- 文件夹删除时需要处理其下的笔记
- 批量限制: 每次最多同步100条操作

### 1.4 状态管理接口

**获取同步状态接口** (`/api/sync/status`):

Query参数:
| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `include` | string | 否 | 包含的额外信息,逗号分隔 (queue, conflicts, devices, stats) |

响应结构:
```typescript
interface SyncStatusResponse {
  success: true;
  data: {
    status: {
      lastSyncTime: number;
      isSyncing: boolean;
      syncMode: 'realtime' | 'offline' | 'polling';
      connectionStatus: 'connected' | 'disconnected' | 'reconnecting';
      connectionType: 'websocket' | 'http';
    };
    queue?: { pending: number; syncing: number; failed: number; total: number; };
    conflicts?: { total: number; unresolved: number; items: Conflict[]; };
    devices?: { current: DeviceInfo; all: DeviceInfo[]; };
    stats?: { totalNotes: number; totalFolders: number; totalReviews: number; syncedNotes: number; syncedFolders: number; syncedReviews: number; pendingChanges: number; };
  };
}
```

**获取同步队列接口** (`/api/sync/queue`):

Query参数:
| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `status` | string | 否 | 按状态筛选 (pending, syncing, failed, resolved) |
| `entity` | string | 否 | 按实体类型筛选 (note, folder, review) |
| `page` | number | 否 | 页码,从1开始 |
| `pageSize` | number | 否 | 每页数量,默认20,最大100 |

**删除队列项接口** (`DELETE /api/sync/queue/:id`):
- 只能删除状态为`failed`或`resolved`的项
- 支持force参数强制删除任意状态的项

### 1.5 冲突解决接口

**解决同步冲突接口** (`/api/sync/resolve`):

请求体:
```typescript
interface ResolveConflictRequest {
  conflictId: string;
  resolution: 'local' | 'remote' | 'merge';
  mergedData?: {
    note?: NoteData;
    folder?: FolderData;
    review?: ReviewData;
  };
  reason?: string;
}
```

响应结构:
```typescript
interface ResolveConflictResponse {
  success: true;
  data: {
    conflictId: string;
    resolved: boolean;
    resolution: 'local' | 'remote' | 'merge';
    appliedData?: any;
    timestamp: number;
    pushInfo: {
      pushed: boolean;
      devices: string[];
    };
  };
}
```

### 1.6 差异检测接口

**获取数据差异接口** (`/api/sync/diff`):

请求体:
```typescript
interface SyncDiffRequest {
  localSnapshot: {
    notes?: NoteSnapshot[];
    folders?: FolderSnapshot[];
    reviews?: ReviewSnapshot[];
  };
  options?: {
    entities?: ('note' | 'folder' | 'review')[];
    since?: number;
    includeDeleted?: boolean;
    detailed?: boolean;
  };
}
```

### 1.7 通用设计规范

**认证方式**: Bearer Token (JWT)

**限流策略**:
| 接口类型 | 限流规则 |
|---------|---------|
| WebSocket连接 | 每用户每分钟最多10次连接尝试 |
| 同步接口 | 每用户每秒最多5次请求 |
| 查询接口 | 每用户每分钟最多100次请求 |

**错误处理**:
- 标准错误响应格式包含错误代码、错误描述、详细信息
- 错误代码命名: 大写下划线分隔 (如: UNAUTHORIZED)

**版本控制机制**:
- 每个实体都有version字段,每次修改递增
- 冲突检测: IF local.version != remote.version AND local.contentHash != remote.contentHash THEN 检测到冲突
- 乐观锁: 更新时检查version,不匹配则拒绝更新

---

## 2. 前端缓存API接口设计

### 2.1 缓存API概览

| 操作类别 | 方法列表 | 优先级 |
|---------|----------|--------|
| 基础操作 | get, set, delete, clear | P0 |
| 批量操作 | getMany, setMany, deleteMany | P0 |
| 查询操作 | find | P1 |
| 同步队列操作 | enqueue, dequeue, getQueue, clearQueue | P0 |
| 同步状态操作 | getSyncStatus, setSyncStatus | P0 |
| 数据差异操作 | getDiff | P2 |

### 2.2 基础操作

**get<T>(key: string)**:
- 从混合缓存中获取数据
- 先查L1 Memory Cache (<1ms)
- 再查L2 IndexedDB (5-10ms)
- 最后查L3 localStorage (<1ms)
- 返回带有版本和过期时间的CacheData<T>

**set<T>(key: string, data: T, ttl?: number)**:
- 写透策略: 同时更新L1、L2、L3
- 自动计算contentHash (SHA-256)
- 设置过期时间 (可选)
- 触发缓存更新事件

**delete(key: string)**:
- 从L1、L2、L3中删除指定key
- 触发缓存失效事件
- 更新缓存统计信息

**clear()**:
- 清空所有三层缓存
- 触发缓存清空事件
- 重置缓存统计信息

### 2.3 批量操作

**getMany<T>(keys: string[])**:
- 批量获取多个key的数据
- 返回Map<string, CacheData<T>>
- 支持按需加载策略
- 优化多次查询性能

**setMany<T>(items: Map<string, T>)**:
- 批量写入多个key-value对
- 使用IndexedDB事务批量写入
- 批量更新L1 Memory Cache
- 批量触发缓存更新事件

**deleteMany(keys: string[])**:
- 批量删除多个key
- 使用IndexedDB事务批量删除
- 批量从L1删除
- 批量触发缓存失效事件

### 2.4 查询操作

**find<T>(predicate: (data: T) => boolean)**:
- 遍历IndexedDB中的所有记录
- 应用predicate函数过滤
- 返回匹配的CacheData<T>数组
- 支持分页和排序

### 2.5 同步队列操作

**enqueue(item: SyncQueueItem)**:
- 将操作加入同步队列
- 按优先级排序插入
- 持久化到IndexedDB
- 触发队列更新事件
- 自动计算内容哈希

**dequeue()**:
- 从队列中取出下一个待处理项
- 按优先级和timestamp排序
- 更新项状态为processing
- 返回SyncQueueItem或null

**getQueue()**:
- 获取所有队列项
- 支持按状态筛选
- 支持分页和排序
- 返回SyncQueueItem[]

**clearQueue()**:
- 清空所有队列项
- 清空IndexedDB中的syncQueue存储
- 重置队列统计
- 触发队列清空事件

### 2.6 同步状态操作

**getSyncStatus()**:
- 从localStorage读取同步状态
- 包含: lastSyncTime, isSyncing, pendingItems, failedItems, conflictItems, syncMode, connectionStatus
- 快速读取,无需查询IndexedDB

**setSyncStatus(status: Partial<SyncStatus>)**:
- 更新同步状态
- 合并到现有状态
- 持久化到localStorage
- 触发状态变更事件

### 2.7 数据差异操作

**getDiff(lastSyncTime: number)**:
- 对比本地数据和服务器数据
- 返回DiffResult:
  ```typescript
  interface DiffResult {
    localOnly: DiffItem[];  // 仅存在于本地的记录
    remoteOnly: DiffItem[];  // 仅存在于远程的记录
    modified: DiffItem[];  // 版本或内容不同的记录
    conflicts: Conflict[];  // 检测到冲突
    timestamp: number;
  }
  ```

### 2.8 缓存数据结构

```typescript
interface CacheData<T> {
  data: T;
  timestamp: number;
  version: number;
  hash: string;
  expiresAt?: number;
}

interface SyncQueueItem {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: 'note' | 'folder' | 'review';
  entityId: number;
  data: any;
  timestamp: number;
  retryCount: number;
  status: 'pending' | 'syncing' | 'failed' | 'resolved';
  errorMessage?: string;
  version: number;
  contentHash: string;
}

interface SyncStatus {
  lastSyncTime: number;
  isSyncing: boolean;
  pendingItems: number;
  failedItems: number;
  conflictItems: number;
  syncMode: 'realtime' | 'offline' | 'polling';
  connectionStatus: 'connected' | 'disconnected' | 'reconnecting';
}
```

---

## 3. 后端同步服务实现架构

### 3.1 SyncService类结构

**核心模块划分**:

```
SyncService
├── WebSocket连接管理模块
│   ├── 连接池管理器
│   ├── 状态追踪器
│   ├── 消息分发器
│   └── 心跳控制器
├── 同步操作处理模块
│   ├── 操作调度器
│   ├── 执行引擎
│   ├── 队列管理器
│   └── 批处理器
├── 冲突检测和解决模块
│   ├── 冲突检测引擎
│   ├── 解决策略执行器
│   ├── 合并算法器
│   └── 冲突日志记录器
├── 同步状态管理模块
│   ├── 状态机
│   ├── 状态持久化器
│   ├── 状态查询器
│   └── 状态变更通知器
├── 广播通知模块
│   ├── 事件发布器
│   ├── 订阅管理器
│   ├── 优先级队列
│   └── 消息压缩器
├── 错误处理和重试模块
│   ├── 错误分类器
│   ├── 重试调度器
│   ├── 死信队列管理器
│   └── 降级控制器
└── 性能优化模块
    ├── 缓存管理器
    ├── 批量处理器
    ├── 数据压缩器
    └── 连接复用器
```

### 3.2 冲突检测和解决

**冲突检测算法**:
```
IF local.version != remote.version THEN
  IF local.contentHash != remote.contentHash THEN
    检测到冲突
  END IF
END IF
```

**冲突类型**:
- `CONTENT` - 内容冲突: 同一记录被多方修改
- `VERSION` - 版本冲突: 本地版本与服务器版本不一致
- `DELETE` - 删除冲突: 一方删除,另一方修改
- `PARENT` - 父级冲突: 父记录不存在或被删除
- `UNIQUE` - 唯一性冲突: 重复的唯一键

**冲突解决策略**:

| 策略 | 优先级 | 说明 |
|------|--------|------|
| `LATEST_WINS` | 默认 | 最后修改的版本胜出 |
| `SERVER_WINS` | 默认 | 服务器版本覆盖本地版本 |
| `CLIENT_WINS` | 备用 | 客户端版本覆盖服务器版本 |
| `MERGE` | P1 | 智能合并两个版本 |
| `MANUAL` | P0 | 用户手动选择或合并 |

### 3.3 错误处理和重试机制

**错误分类**:

| 错误类型 | 识别方式 | 处理策略 | 重试策略 |
|----------|----------|----------|----------|
| 网络错误 | 连接超时、网络中断 | 记录错误、通知客户端 | 指数退避重试 |
| 认证错误 | Token无效、权限不足 | 拒绝操作、断开连接 | 不重试 |
| 数据错误 | 数据格式错误、验证失败 | 记录错误、返回错误信息 | 不重试 |
| 并发错误 | 版本冲突、记录不存在 | 触发冲突解决机制 | 不重试 |
| 数据库错误 | 连接失败、查询错误 | 记录错误、重试操作 | 有限重试 |
| 系统错误 | 内存不足、CPU超载 | 限流、降级服务 | 有限重试 |

**重试机制**:
- 指数退避: 初始延迟1秒,每次重试延迟翻倍 (1s, 2s, 4s, 8s, 30s)
- 最大重试次数: 3次 (可配置)
- 死信队列: 存储重试失败的操作

### 3.4 性能优化策略

**批处理优化**:
- 批量插入: 使用Prisma的createMany
- 批量更新: 使用Prisma的updateMany
- 批量删除: 使用Prisma的deleteMany
- 分批处理: 大批量数据分批处理 (默认100条/批)

**数据压缩**:
- 消息大小 > 1KB: 启用压缩
- 消息大小 > 10KB: 强制压缩
- 压缩算法: gzip、brotli (根据客户端支持自动选择)

**缓存策略**:

| 层级 | 缓存类型 | 存储位置 | 过期时间 | 使用场景 |
|------|----------|----------|----------|----------|
| L1 | 内存缓存 | 服务内存 | 5分钟 | 热点数据、频繁访问的数据 |
| L2 | Redis缓存 | Redis | 1小时 | 用户同步状态、连接信息 |
| L3 | 数据库缓存 | PostgreSQL | 24小时 | 历史同步记录、冲突日志 |

---

## 4. 前端同步管理器设计

### 4.1 SyncManager类结构

**核心组件**:
```typescript
class SyncManager {
  // 核心依赖
  private cache: HybridCache
  private wsClient: WebSocketClient
  private httpClient: HttpClient
  private eventBus: EventBus
  
  // 连接状态管理
  private connectionState: ConnectionState
  private reconnectAttempts: number
  
  // 同步队列管理
  private syncQueue: SyncQueue
  private pendingOperations: Map<string, SyncOperation>
  
  // 冲突管理
  private conflictManager: ConflictManager
  private pendingConflicts: Map<string, Conflict>
  
  // 配置
  private config: SyncManagerConfig
  
  // 状态标识
  private isInitialized: boolean
  private isOnline: boolean
  private isSyncing: boolean
}
```

### 4.2 连接管理

**连接状态机**:
```
[DISCONNECTED] → [CONNECTING] → [AUTHENTICATED] → [CONNECTED]
     ↑                  ↓                  ↓             ↓
     └───────────── [RECONNECTING] ←─────────────────────┘
                         ↓
                   [FALLBACK_HTTP]
```

**重连机制**:
- 指数退避策略: 1s, 2s, 4s, 8s, 30s
- 最大重试次数: 5次
- 超过最大重试后: 切换到HTTP降级模式

### 4.3 同步操作

**同步方法**:
- `syncNotes()` - 笔记同步
- `syncReviews()` - 复盘同步
- `syncFolders()` - 文件夹同步
- `syncAll()` - 全量同步 (串行执行: folders → notes → reviews)

**同步优先级**:

| 优先级 | 场景 | 说明 |
|--------|------|------|
| HIGH | 用户主动操作 | 立即同步 |
| MEDIUM | 定时同步 | 5分钟一次 |
| LOW | 后台同步 | 空闲时执行 |

### 4.4 冲突处理

**冲突检测流程**:
1. 接收服务器更新时检测
2. 同步本地变更时检测
3. 检测算法: 版本检测 + 内容哈希检测

**冲突解决策略**:
1. `LAST_WRITE_WINS` - 最后修改优先 (默认)
2. `USER_CHOICE` - 用户选择
3. `MANUAL_MERGE` - 手动合并
4. `SERVER_WINS` - 服务器优先 (备用)

### 4.5 事件系统

**事件类型**:
- 连接事件: `CONNECTED`, `DISCONNECTED`, `RECONNECTING`, `CONNECTION_ERROR`
- 同步事件: `SYNC_STARTED`, `SYNC_PROGRESS`, `SYNC_COMPLETED`, `SYNC_FAILED`
- 冲突事件: `CONFLICT_DETECTED`, `CONFLICT_RESOLVED`
- 数据事件: `NOTE_CREATED`, `NOTE_UPDATED`, `NOTE_DELETED`, 等
- 状态事件: `ONLINE`, `OFFLINE`, `QUEUE_CHANGED`

### 4.6 离线/在线状态切换

**离线模式处理**:
- 停止WebSocket心跳
- 暂停同步队列
- 保存同步队列到缓存
- 所有操作记录为离线操作
- 存入OFFLINE_EDITS缓存

**在线模式恢复**:
- 尝试重连WebSocket
- 加载离线编辑内容
- 批量同步离线操作
- 处理冲突 (如果有)

---

## 5. 前后端集成方案

### 5.1 集成流程

**完整的同步流程**:

```
用户操作
  ↓
更新本地缓存 (HybridCache)
  ↓
加入同步队列 (SyncManager)
  ↓
发送到服务器 (WebSocket/HTTP)
  ↓
服务器处理操作 (SyncService)
  ↓
检测冲突
  ├─ 无冲突 → 执行操作 → 更新数据库 → 广播更新
  └─ 有冲突 → 记录冲突 → 通知客户端 → 等待用户解决
  ↓
返回同步响应
  ↓
更新本地缓存
  ↓
触发UI更新
```

### 5.2 数据流设计

**WebSocket实时同步流程**:
```
客户端连接 → WebSocket握手 → 认证 → 订阅频道 → 开始心跳
  ↓
客户端发送同步请求 → 服务器处理 → 检测冲突 → 执行操作 → 生成响应
  ↓
服务器广播更新 → 其他客户端接收 → 更新本地缓存 → 触发UI更新
```

**HTTP降级同步流程**:
```
客户端发送HTTP请求 → 服务器处理 → 检测冲突 → 执行操作 → 生成响应
  ↓
客户端轮询更新 → 服务器获取更新 → 返回更新 → 客户端更新缓存
```

### 5.3 异常处理机制

**连接异常处理**:
- 连接超时 (>5秒): 重连 (指数退避)
- 连接频繁断开 (1分钟内>3次): 切换到HTTP降级
- 认证失败: 重新获取token后重连

**同步异常处理**:
- 网络错误: 加入队列,等待重试
- 认证错误: 重新认证
- 服务器错误: 记录错误,降级到HTTP
- 版本冲突: 触发冲突解决机制

### 5.4 认证和安全机制

**JWT认证**:
- Token有效期: 24小时
- 刷新机制: 提供refresh token
- 请求头格式: `Authorization: Bearer <JWT_TOKEN>`

**设备绑定**:
- 每设备唯一标识
- 每用户最多1个活跃连接
- 设备连接被替换时通知

**数据安全**:
- WebSocket连接加密 (WSS)
- 敏感数据加密传输
- 同步操作审计日志

### 5.5 性能优化策略

**请求优化**:
- 批量发送操作 (最多10个/批)
- 去重优化: 相同实体的连续操作只保留最新的
- 合并优化: 相同实体的create和update合并为create

**传输优化**:
- 消息压缩 (>1KB)
- 增量同步 (只传输变更)
- 数据快照对比 (避免传输完整数据)

**缓存优化**:
- 写透策略: 写入缓存的同时写入服务器
- 写回策略: 离线编辑只更新缓存,网络恢复后同步
- 失效策略: 版本变更时使缓存失效

---

## 6. 同步状态UI设计

### 6.1 同步状态组件

**紧凑模式 - 顶部导航栏集成**:

| 状态 | 图标 | 颜色 | 动画 | 提示文本 |
|------|------|------|------|----------|
| 已连接/空闲 | ✓ | `--color-success-500` | 无 | "已同步" |
| 正在同步 | ⟳ | `--color-primary-500` | 旋转动画 | "同步中..." |
| 待同步 | ! | `--color-warning-500` | 脉冲动画 | "X项待同步" |
| 同步失败 | ✕ | `--color-error-500` | 抖动动画 | "同步失败" |
| 冲突 | ⚠ | `--color-warning-600` | 脉冲动画 | "X个冲突" |
| 离线 | ⭕ | `--color-gray-400` | 无 | "离线模式" |
| 重连中 | ⟳ | `--color-primary-400` | 旋转动画 | "重连中..." |

**展开模式 - 点击后显示详情面板**:
- 显示同步状态、上一次同步时间
- 显示待同步列表
- 显示失败项列表
- 显示冲突列表
- 提供立即同步、重试全部等操作按钮

### 6.2 冲突解决组件

**冲突列表视图**:
- 显示冲突列表 (分页)
- 每个冲突显示本地版本和远程版本
- 提供三种解决方案: 使用本地、使用远程、手动合并
- 支持批量解决: 全部使用本地、全部使用远程、批量手动合并

**手动合并界面**:
- 字段对比视图
- 高亮显示冲突字段
- 支持选择本地、远程或自定义版本
- 对于文本内容,提供行级差异对比
- 支持直接编辑合并结果

**冲突卡片状态**:

| 状态 | 视觉表现 | 说明 |
|------|----------|------|
| 未解决 | 黄色边框 + 警告图标 | 等待用户处理 |
| 解决中 | 蓝色边框 + 加载动画 | 正在应用解决方案 |
| 已解决 | 绿色边框 + 勾选图标 | 冲突已解决 |
| 已跳过 | 灰色边框 + 禁用状态 | 用户选择跳过 |

### 6.3 同步队列组件

**队列列表视图**:
- 支持按状态筛选: 全部、待同步、同步中、失败
- 支持按时间排序
- 显示每个队列项的详细信息
- 提供重试、删除操作
- 支持批量操作: 重试选定、删除选定

**队列项状态**:

| 状态 | 图标 | 颜色 | 边框 | 动画 |
|------|------|------|------|------|
| 待同步 | 时钟图标 | `--color-warning-500` | 虚线 | 无 |
| 同步中 | 旋转图标 | `--color-primary-500` | 实线蓝 | 旋转 |
| 失败 | 错误图标 | `--color-error-500` | 实线红 | 抖动 |
| 已完成 | 勾选图标 | `--color-success-500` | 实线绿 | 淡出 |

### 6.4 离线提示组件

**顶部横幅 - 离线状态**:
- 显示离线模式提示
- 显示待同步数量
- 提供"了解更多"和"关闭"按钮

**编辑器内提示 - 离线编辑**:
- 在编辑器标题旁显示"离线"标签
- 显示"保存到本地"按钮
- 显示提示信息告知用户将在恢复连接后同步

**恢复连接提示**:
- 恢复连接后显示同步进度
- 显示当前同步的项目
- 显示同步百分比

### 6.5 操作反馈机制

**Toast通知**:

| 类型 | 示例 | 自动关闭时间 |
|------|------|-------------|
| 成功 | "✓ 同步完成 - 已同步 3 项更改" | 3秒 |
| 失败 | "✕ 同步失败 - 1 项同步失败,点击查看详情" | 不自动关闭 |
| 警告 | "⚠ 检测到冲突 - 发现 2 个冲突需要解决" | 5秒 |
| 信息 | "⚠ 已切换到离线模式" | 5秒 |

**进度指示器**:
- 显示当前进度百分比
- 显示当前正在同步的项目
- 显示预计剩余时间
- 支持取消操作

**内联反馈**:
- 在列表项旁显示同步状态
- 点击状态可查看详情或执行操作
- 状态更新时有动画过渡

### 6.6 响应式设计

**断点适配**:

| 断点 | 同步状态指示器 | 冲突解决 | 同步队列 | Toast |
|------|---------------|---------|---------|-------|
| Mobile (<640px) | 紧凑模式,全宽 Modal | 全屏 Modal | 全屏 Modal | 全宽 Toast |
| Tablet (640-1024px) | 紧凑模式 | 宽 Modal | 宽 Modal | 标准 Toast |
| Desktop (>1024px) | 紧凑模式 + 展开面板 | 标准宽 Modal | 标准宽 Modal | 标准 Toast |

---

## 7. 关键决策回顾

### 决策1: 后端同步API接口设计
- 设计了9个核心接口,覆盖WebSocket连接、同步操作、状态管理、冲突解决、差异检测
- 所有接口使用JWT认证,支持限流和错误处理
- 批量操作限制: 笔记100条,复盘50条,文件夹100条

### 决策2: 前端缓存API接口设计
- 设计了6类操作: 基础、批量、查询、同步队列、同步状态、数据差异
- 采用三层缓存架构: L1 Memory + L2 IndexedDB + L3 localStorage
- 写透策略用于实时同步,写回策略用于离线编辑

### 决策3: 后端同步服务架构
- 采用分层模块化设计,包含7个核心模块
- 冲突检测基于版本号和内容哈希
- 错误处理采用指数退避重试,支持死信队列

### 决策4: 前端同步管理器架构
- 核心组件: HybridCache、WebSocketClient、HttpClient、EventBus
- 连接状态机支持多种状态转换
- 事件系统驱动UI更新

### 决策5: 前后端集成方案
- WebSocket实时同步为主,HTTP降级为备
- 数据流设计: 用户操作 → 更新缓存 → 加入队列 → 发送到服务器 → 处理 → 广播更新
- 性能优化: 批量发送、消息压缩、增量同步

### 决策6: 同步状态UI设计
- 5个核心组件: SyncStatusIndicator、ConflictResolution、SyncQueue、OfflineIndicator、SyncFeedback
- 支持紧凑模式和展开模式
- 完整的Toast通知系统和进度指示器

---

## 8. 批次3会后行动项

| 任务 | 负责人 | 截止时间 | 优先级 |
|------|--------|----------|--------|
| 编写后端同步API接口文档 | 后端架构师 | 批次3结束后24小时内 | P0 |
| 编写前端缓存API接口文档 | 前端架构师 | 批次3结束后24小时内 | P0 |
| 编写前后端集成方案文档 | 前端架构师、后端架构师 | 批次3结束后24小时内 | P0 |
| 编写同步状态UI设计文档 | 前端架构师 | 批次3结束后24小时内 | P0 |

---

## 9. 下一步计划

### 批次4: 任务分解、测试与协作
- 分解T3项目任务
- 确定任务时间线和里程碑
- 制定测试计划
- 确定智能体协作机制

### 批次4参与人员
- 全体智能体
- 预计时间: 75分钟
- 预计时间: 2026-01-20 15:30-16:45

---

**文档编制**: 会议记录人
**文档审核**: 项目负责人
**文档批准**: 项目负责人
**最后更新**: 2026-01-10
