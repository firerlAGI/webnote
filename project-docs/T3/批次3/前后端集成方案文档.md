# T3项目前后端集成方案文档

## 概述

本文档详细描述了T3项目前端与后端的集成方案，包括完整的数据流设计、WebSocket连接管理、同步状态机、离线/在线切换处理、冲突检测与解决流程，以及错误处理和重试机制。

## 目录

1. [数据流设计](#数据流设计)
2. [WebSocket连接管理](#websocket连接管理)
3. [同步状态机设计](#同步状态机设计)
4. [离线/在线切换处理](#离线在线切换处理)
5. [冲突检测与解决](#冲突检测与解决)
6. [三层缓存一致性保障](#三层缓存一致性保障)
7. [错误处理和重试机制](#错误处理和重试机制)

---

## 数据流设计

### 创建笔记数据流

```
用户操作
    ↓
前端UI组件
    ↓
HybridCache.set() - 写入L1缓存
    ↓
SyncManager.addToSyncQueue() - 添加到同步队列
    ↓
WebSocket.send() - 发送同步请求
    ↓
后端SyncService.processSyncRequest() - 处理同步请求
    ↓
后端数据库存储
    ↓
WebSocket.broadcast() - 广播更新
    ↓
前端接收服务器推送
    ↓
HybridCache.set() - 更新缓存
    ↓
前端UI更新
```

**代码示例:**

```typescript
// 前端：创建笔记
async function createNote(note: Note): Promise<void> {
  // 1. 写入缓存
  await cache.set(`note:${note.id}`, note, {
    tags: ['note'],
    version: 1
  });
  
  // 2. 添加到同步队列
  await syncManager.addToSyncQueue({
    operationId: generateId(),
    operationType: 'create',
    entityType: 'note',
    entityId: note.id,
    data: note,
    status: 'pending',
    createdAt: Date.now()
  });
  
  // 3. 发送同步请求
  await syncManager.sync();
}

// 后端：处理创建操作
async executeCreate(operation: SyncOperation): Promise<OperationResult> {
  const { entity_type, entity_id, data } = operation;
  
  // 1. 检查冲突
  const conflict = await this.detectConflict(operation);
  if (conflict) {
    return { success: false, conflict };
  }
  
  // 2. 写入数据库
  const entity = await this.db[entity_type].create({
    ...data,
    content_hash: this.computeContentHash(data)
  });
  
  // 3. 广播更新
  this.broadcastUpdate({
    entity_type,
    entity_id: entity.id,
    operation_type: 'create',
    data: entity
  });
  
  return { success: true, entity_id: entity.id, data: entity };
}
```

### 更新笔记数据流

```
用户编辑笔记
    ↓
前端UI组件
    ↓
HybridCache.get() - 获取当前版本
    ↓
用户修改内容
    ↓
HybridCache.set() - 写入L1缓存（新版本）
    ↓
SyncManager.addToSyncQueue() - 添加到同步队列
    ↓
WebSocket.send() - 发送更新请求（带版本号）
    ↓
后端SyncService.processSyncRequest() - 处理更新请求
    ↓
版本号检测 - 比对客户端版本与服务器版本
    ↓
后端数据库更新
    ↓
content_hash计算 - 计算新的内容哈希
    ↓
WebSocket.broadcast() - 广播更新
    ↓
前端接收服务器推送
    ↓
HybridCache.set() - 更新缓存
    ↓
前端UI更新
```

**代码示例:**

```typescript
// 前端：更新笔记
async function updateNote(noteId: string, updates: Partial<Note>): Promise<void> {
  // 1. 获取当前版本
  const current = await cache.get<Note>(`note:${noteId}`);
  if (!current) throw new Error('Note not found');
  
  // 2. 合并更新
  const updated = { ...current.data, ...updates };
  const newVersion = (current.version || 0) + 1;
  
  // 3. 写入缓存
  await cache.set(`note:${noteId}`, updated, {
    version: newVersion,
    tags: ['note']
  });
  
  // 4. 添加到同步队列
  await syncManager.addToSyncQueue({
    operationId: generateId(),
    operationType: 'update',
    entityType: 'note',
    entityId: noteId,
    data: { before_version: current.version, ...updates },
    status: 'pending',
    createdAt: Date.now()
  });
  
  // 5. 发送同步请求
  await syncManager.sync();
}

// 后端：处理更新操作
async executeUpdate(operation: SyncOperation): Promise<OperationResult> {
  const { entity_id, entity_type, data, before_version } = operation;
  
  // 1. 获取当前服务器版本
  const current = await this.db[entity_type].findUnique({
    where: { id: entity_id }
  });
  
  // 2. 版本号检测
  if (current.version !== before_version) {
    // 版本不匹配，存在冲突
    return {
      success: false,
      conflict: {
        conflict_type: ConflictType.VERSION,
        entity_type,
        entity_id,
        server_data: current,
        client_data: data,
        server_version: current.version,
        client_version: before_version
      }
    };
  }
  
  // 3. 计算内容哈希
  const newContentHash = this.computeContentHash(data);
  if (newContentHash === current.content_hash) {
    // 内容未变化
    return { success: true, entity_id, data: current };
  }
  
  // 4. 更新数据库
  const updated = await this.db[entity_type].update({
    where: { id: entity_id },
    data: {
      ...data,
      version: current.version + 1,
      content_hash: newContentHash
    }
  });
  
  // 5. 广播更新
  this.broadcastUpdate({
    entity_type,
    entity_id,
    operation_type: 'update',
    data: updated,
    version: updated.version
  });
  
  return { success: true, entity_id, data: updated, new_version: updated.version };
}
```

### 删除笔记数据流

```
用户删除笔记
    ↓
前端UI组件
    ↓
HybridCache.get() - 获取当前版本
    ↓
HybridCache.delete() - 从缓存中删除
    ↓
SyncManager.addToSyncQueue() - 添加到同步队列
    ↓
WebSocket.send() - 发送删除请求
    ↓
后端SyncService.processSyncRequest() - 处理删除请求
    ↓
版本号检测 - 比对客户端版本与服务器版本
    ↓
后端数据库删除（软删除）
    ↓
WebSocket.broadcast() - 广播删除事件
    ↓
前端接收服务器推送
    ↓
HybridCache.delete() - 确认删除
    ↓
前端UI更新
```

**代码示例:**

```typescript
// 前端：删除笔记
async function deleteNote(noteId: string): Promise<void> {
  // 1. 获取当前版本
  const current = await cache.get<Note>(`note:${noteId}`);
  const version = current?.version || 0;
  
  // 2. 从缓存删除
  await cache.delete(`note:${noteId}`);
  
  // 3. 添加到同步队列
  await syncManager.addToSyncQueue({
    operationId: generateId(),
    operationType: 'delete',
    entityType: 'note',
    entityId: noteId,
    data: { before_version: version },
    status: 'pending',
    createdAt: Date.now()
  });
  
  // 4. 发送同步请求
  await syncManager.sync();
}

// 后端：处理删除操作
async executeDelete(operation: SyncOperation): Promise<OperationResult> {
  const { entity_id, entity_type, data, before_version } = operation;
  
  // 1. 获取当前服务器版本
  const current = await this.db[entity_type].findUnique({
    where: { id: entity_id }
  });
  
  if (!current) {
    // 资源不存在
    return { success: true, entity_id };
  }
  
  // 2. 版本号检测
  if (current.version !== before_version) {
    return {
      success: false,
      conflict: {
        conflict_type: ConflictType.DELETE,
        entity_type,
        entity_id,
        server_data: current,
        client_data: data,
        server_version: current.version,
        client_version: before_version
      }
    };
  }
  
  // 3. 软删除
  await this.db[entity_type].update({
    where: { id: entity_id },
    data: { deleted: true, deleted_at: new Date() }
  });
  
  // 4. 广播删除事件
  this.broadcastUpdate({
    entity_type,
    entity_id,
    operation_type: 'delete',
    data: { id: entity_id, deleted: true }
  });
  
  return { success: true, entity_id };
}
```

---

## WebSocket连接管理

### 连接建立过程

```
1. 前端发起WebSocket连接
   ws://localhost:3000/api/sync/ws

2. 发送握手消息
   {
     "type": "handshake",
     "message_id": "msg_001",
     "client_id": "client_abc123",
     "client_info": { "device_type": "desktop", ... },
     "protocol_version": "1.0.0"
   }

3. 服务器响应握手
   {
     "type": "handshake",
     "success": true,
     "connection_id": "conn_xyz789"
   }

4. 发送认证消息
   {
     "type": "auth",
     "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
   }

5. 服务器验证JWT
   - 验证token有效性
   - 提取user_id
   - 关联connection_id和user_id

6. 认证成功响应
   {
     "type": "auth",
     "success": true,
     "user_id": 1,
     "current_state": {
       "last_sync_time": "...",
       "pending_operations": 0
     }
   }

7. 启动心跳机制
   - 客户端每30秒发送ping
   - 服务器响应pong
   - 超过60秒未收到pong则断开

8. 连接建立完成，开始同步
```

**代码示例:**

```typescript
// 前端：WebSocket连接管理
class WebSocketClient {
  private ws: WebSocket | null = null;
  private connectionId: string | null = null;
  private userId: number | null = null;
  private heartbeatTimer: number | null = null;
  private reconnectTimer: number | null = null;
  private reconnectAttempts = 0;
  private readonly maxReconnectAttempts = 5;
  private readonly reconnectDelays = [1000, 2000, 4000, 8000, 30000];

  async connect(token: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const ws = new WebSocket('ws://localhost:3000/api/sync/ws');
      
      ws.onopen = () => {
        console.log('WebSocket连接已建立');
        this.ws = ws;
        this.sendHandshake();
      };
      
      ws.onmessage = (event) => {
        this.handleMessage(JSON.parse(event.data));
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket错误:', error);
        reject(error);
      };
      
      ws.onclose = () => {
        console.log('WebSocket连接已关闭');
        this.handleDisconnect();
      };
    });
  }

  private sendHandshake(): void {
    const message = {
      type: 'handshake',
      message_id: generateMessageId(),
      timestamp: new Date().toISOString(),
      client_id: this.clientId,
      client_info: this.getClientInfo(),
      protocol_version: '1.0.0'
    };
    this.ws!.send(JSON.stringify(message));
  }

  private sendAuth(token: string): void {
    const message = {
      type: 'auth',
      message_id: generateMessageId(),
      timestamp: new Date().toISOString(),
      token
    };
    this.ws!.send(JSON.stringify(message));
  }

  private startHeartbeat(): void {
    this.heartbeatTimer = window.setInterval(() => {
      this.sendPing();
    }, 30000); // 30秒间隔
  }

  private sendPing(): void {
    const message = {
      type: 'ping',
      timestamp: new Date().toISOString()
    };
    this.ws!.send(JSON.stringify(message));
  }

  private handleMessage(message: any): void {
    switch (message.type) {
      case 'handshake':
        if (message.success) {
          this.connectionId = message.connection_id;
          this.sendAuth(this.token);
        }
        break;
      
      case 'auth':
        if (message.success) {
          this.userId = message.user_id;
          this.startHeartbeat();
          this.reconnectAttempts = 0;
          this.emit('connected', message.current_state);
        }
        break;
      
      case 'pong':
        // 心跳响应，重置超时检测
        break;
      
      case 'sync_response':
        this.handleSyncResponse(message);
        break;
      
      case 'server_update':
        this.handleServerUpdate(message);
        break;
      
      case 'conflict':
        this.handleConflict(message);
        break;
    }
  }

  private handleDisconnect(): void {
    this.stopHeartbeat();
    
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = this.reconnectDelays[this.reconnectAttempts];
      console.log(`${delay}ms后尝试重连...`);
      
      this.reconnectTimer = setTimeout(() => {
        this.reconnectAttempts++;
        this.connect(this.token);
      }, delay);
    } else {
      this.emit('fallback_to_http');
      this.useHttpFallback();
    }
  }

  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
}
```

```typescript
// 后端：WebSocket连接管理
export class SyncService {
  private activeConnections: Map<string, WebSocketConnection> = new Map();
  private heartbeatTimers: Map<string, NodeJS.Timeout> = new Map();
  
  handleConnection(ws: WebSocket, token: string): void {
    const connectionId = generateConnectionId();
    const connection: WebSocketConnection = {
      connection_id: connectionId,
      user_id: null,
      client_id: null,
      device_id: null,
      status: 'connecting',
      last_heartbeat: Date.now(),
      missed_heartbeats: 0
    };
    
    this.activeConnections.set(connectionId, connection);
    
    ws.on('message', (data) => {
      this.handleMessage(ws, connectionId, JSON.parse(data.toString()));
    });
    
    ws.on('close', () => {
      this.handleDisconnect(connectionId);
    });
    
    ws.on('error', (error) => {
      this.logger.error(`WebSocket错误: ${error}`);
      this.handleDisconnect(connectionId);
    });
  }

  private handleMessage(ws: WebSocket, connectionId: string, message: any): void {
    const connection = this.activeConnections.get(connectionId);
    if (!connection) return;
    
    switch (message.type) {
      case 'handshake':
        this.handleHandshake(ws, connection, message);
        break;
      
      case 'auth':
        this.handleAuth(ws, connection, message);
        break;
      
      case 'ping':
        this.handlePing(ws, connection);
        break;
      
      case 'sync':
        this.handleSyncRequest(ws, connection, message);
        break;
    }
  }

  private handleHandshake(ws: WebSocket, connection: WebSocketConnection, message: any): void {
    connection.client_id = message.client_id;
    connection.client_info = message.client_info;
    connection.device_id = message.client_info.device_type;
    connection.status = 'handshake';
    
    const response = {
      type: 'handshake',
      message_id: message.message_id,
      timestamp: new Date().toISOString(),
      success: true,
      server_id: this.config.serverId,
      protocol_version: '1.0.0',
      connection_id: connection.connection_id
    };
    
    ws.send(JSON.stringify(response));
  }

  private handleAuth(ws: WebSocket, connection: WebSocketConnection, message: any): void {
    try {
      const decoded = jwt.verify(message.token, this.config.jwtSecret) as JWTPayload;
      connection.user_id = decoded.userId;
      connection.status = 'authenticated';
      
      const currentState = this.getClientState(connection.user_id, connection.client_id);
      
      const response = {
        type: 'auth',
        message_id: message.message_id,
        timestamp: new Date().toISOString(),
        success: true,
        user_id: connection.user_id,
        current_state: currentState
      };
      
      ws.send(JSON.stringify(response));
      
      this.startHeartbeat(connection.connection_id);
    } catch (error) {
      const response = {
        type: 'auth',
        message_id: message.message_id,
        timestamp: new Date().toISOString(),
        success: false,
        error: 'Invalid token'
      };
      
      ws.send(JSON.stringify(response));
      ws.close();
    }
  }

  private startHeartbeat(connectionId: string): void {
    const timer = setInterval(() => {
      const connection = this.activeConnections.get(connectionId);
      if (!connection) {
        clearInterval(timer);
        return;
      }
      
      const now = Date.now();
      const elapsed = now - connection.last_heartbeat;
      
      if (elapsed > this.config.heartbeatTimeout) {
        connection.missed_heartbeats++;
        
        if (connection.missed_heartbeats >= 2) {
          this.handleDisconnect(connectionId);
          clearInterval(timer);
        }
      } else {
        connection.missed_heartbeats = 0;
      }
    }, this.config.heartbeatInterval);
    
    this.heartbeatTimers.set(connectionId, timer);
  }

  private handlePing(ws: WebSocket, connection: WebSocketConnection): void {
    connection.last_heartbeat = Date.now();
    connection.missed_heartbeats = 0;
    
    const response = {
      type: 'pong',
      timestamp: new Date().toISOString()
    };
    
    ws.send(JSON.stringify(response));
  }

  private handleDisconnect(connectionId: string): void {
    const connection = this.activeConnections.get(connectionId);
    if (!connection) return;
    
    this.logger.info(`连接断开: ${connectionId}`);
    
    this.activeConnections.delete(connectionId);
    
    const timer = this.heartbeatTimers.get(connectionId);
    if (timer) {
      clearInterval(timer);
      this.heartbeatTimers.delete(connectionId);
    }
  }
}
```

### 指数退避重连策略

```typescript
// 前端重连配置
const RECONNECT_DELAYS = [1000, 2000, 4000, 8000, 30000]; // 1s, 2s, 4s, 8s, 30s
const MAX_RECONNECT_ATTEMPTS = RECONNECT_DELAYS.length;

class WebSocketClient {
  private reconnectAttempts = 0;
  private reconnectTimer: number | null = null;

  private handleDisconnect(): void {
    if (this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      const delay = RECONNECT_DELAYS[this.reconnectAttempts];
      
      console.log(`${delay}ms后尝试重连 (${this.reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);
      
      this.reconnectTimer = setTimeout(() => {
        this.reconnectAttempts++;
        this.connect(this.token);
      }, delay);
    } else {
      console.error('重连失败，切换到HTTP轮询模式');
      this.emit('max_reconnect_attempts_reached');
      this.useHttpFallback();
    }
  }

  private resetReconnect(): void {
    this.reconnectAttempts = 0;
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }
}
```

---

## 同步状态机设计

### 状态定义

```typescript
enum SyncConnectionState {
  DISCONNECTED = 'disconnected',         // 未连接
  CONNECTING = 'connecting',               // 连接中
  AUTHENTICATED = 'authenticated',         // 已认证
  CONNECTED = 'connected',                 // 已连接
  RECONNECTING = 'reconnecting',           // 重连中
  FALLBACK_HTTP = 'fallback_http'          // HTTP降级
}

enum SyncOperationState {
  PENDING = 'pending',                    // 等待同步
  SYNCING = 'syncing',                    // 同步中
  SYNCED = 'synced',                      // 已同步
  FAILED = 'failed'                       // 同步失败
}
```

### 状态转换图

```
                    用户触发连接
                         ↓
                  [DISCONNECTED]
                         ↓
                   连接建立成功
                         ↓
                 [CONNECTING] ←─────┐
                         ↓           │
                   认证成功         │
                         ↓           │
               [AUTHENTICATED] ─────┘
                         ↓
                    心跳建立
                         ↓
                  [CONNECTED]
                         ↓
         ┌───────────────┴───────────────┐
         ↓               ↓               ↓
   连接断开        收到推送        同步操作
         ↓               ↓               ↓
   [RECONNECTING]    保持连接      [SYNCING]
         ↓               ↑               ↓
    重连成功 ────────────┘          完成
         ↓                              ↓
    [CONNECTED]                    [CONNECTED]
         
         ↓
    重连失败超过阈值
         ↓
    [FALLBACK_HTTP]
         ↓
    使用HTTP轮询
```

**代码示例:**

```typescript
class SyncManager {
  private connectionState: SyncConnectionState = SyncConnectionState.DISCONNECTED;
  private syncState: SyncOperationState = SyncOperationState.PENDING;

  async connect(): Promise<void> {
    this.connectionState = SyncConnectionState.CONNECTING;
    this.emit('state_changed', { state: this.connectionState });
    
    try {
      await this.wsClient.connect(this.token);
      this.connectionState = SyncConnectionState.CONNECTED;
      this.emit('state_changed', { state: this.connectionState });
    } catch (error) {
      this.connectionState = SyncConnectionState.DISCONNECTED;
      this.emit('state_changed', { state: this.connectionState });
      throw error;
    }
  }

  async sync(): Promise<void> {
    if (this.syncState === SyncOperationState.SYNCING) {
      console.warn('同步已在进行中');
      return;
    }
    
    this.syncState = SyncOperationState.SYNCING;
    this.emit('sync_start');
    
    try {
      const request = await this.buildSyncRequest();
      const response = await this.sendSyncRequest(request);
      await this.processSyncResponse(response);
      
      this.syncState = SyncOperationState.SYNCED;
      this.emit('sync_complete');
    } catch (error) {
      this.syncState = SyncOperationState.FAILED;
      this.emit('sync_error', error);
      throw error;
    }
  }

  private handleDisconnect(): void {
    this.connectionState = SyncConnectionState.RECONNECTING;
    this.emit('state_changed', { state: this.connectionState });
  }

  private handleReconnectSuccess(): void {
    this.connectionState = SyncConnectionState.CONNECTED;
    this.emit('state_changed', { state: this.connectionState });
  }

  private handleFallbackToHttp(): void {
    this.connectionState = SyncConnectionState.FALLBACK_HTTP;
    this.emit('state_changed', { state: this.connectionState });
    this.startHttpPolling();
  }
}
```

### 状态持久化

```typescript
class SyncStateManager {
  private readonly STORAGE_KEY = 'sync_state';
  
  async saveState(state: SyncState): Promise<void> {
    await localStorage.setItem(this.STORAGE_KEY, JSON.stringify({
      connectionState: state.connectionState,
      syncState: state.syncState,
      lastSyncTime: state.lastSyncTime,
      pendingItems: state.pendingItems,
      savedAt: Date.now()
    }));
  }

  async loadState(): Promise<SyncState | null> {
    const saved = localStorage.getItem(this.STORAGE_KEY);
    if (!saved) return null;
    
    const data = JSON.parse(saved);
    
    if (Date.now() - data.savedAt > 86400000) {
      // 超过24小时，丢弃保存的状态
      return null;
    }
    
    return {
      connectionState: data.connectionState,
      syncState: data.syncState,
      lastSyncTime: data.lastSyncTime,
      pendingItems: data.pendingItems
    };
  }

  async clearState(): Promise<void> {
    await localStorage.removeItem(this.STORAGE_KEY);
  }
}
```

---

## 离线/在线切换处理

### 网络状态检测

```typescript
class NetworkMonitor {
  private isOnline = navigator.onLine;
  private listeners: Set<(online: boolean) => void> = new Set();

  constructor() {
    window.addEventListener('online', this.handleOnline.bind(this));
    window.addEventListener('offline', this.handleOffline.bind(this));
  }

  private handleOnline(): void {
    if (!this.isOnline) {
      this.isOnline = true;
      this.notifyListeners(true);
    }
  }

  private handleOffline(): void {
    if (this.isOnline) {
      this.isOnline = false;
      this.notifyListeners(false);
    }
  }

  private notifyListeners(online: boolean): void {
    this.listeners.forEach(listener => listener(online));
  }

  onStatusChange(listener: (online: boolean) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  getStatus(): boolean {
    return this.isOnline;
  }
}

// 使用示例
const networkMonitor = new NetworkMonitor();

networkMonitor.onStatusChange((online) => {
  if (online) {
    console.log('网络已恢复');
    syncManager.handleOnline();
  } else {
    console.log('网络已断开');
    syncManager.handleOffline();
  }
});
```

### 离线队列管理

```typescript
class OfflineQueue {
  private queue: SyncQueueItem[] = [];
  private readonly STORAGE_KEY = 'offline_queue';

  async loadQueue(): Promise<void> {
    const saved = localStorage.getItem(this.STORAGE_KEY);
    if (saved) {
      this.queue = JSON.parse(saved);
    }
  }

  async saveQueue(): Promise<void> {
    await localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.queue));
  }

  async enqueue(item: SyncQueueItem): Promise<void> {
    this.queue.push(item);
    await this.saveQueue();
  }

  async dequeue(): Promise<SyncQueueItem | null> {
    if (this.queue.length === 0) return null;
    
    const item = this.queue.shift();
    await this.saveQueue();
    return item || null;
  }

  async clear(): Promise<void> {
    this.queue = [];
    await this.saveQueue();
  }

  size(): number {
    return this.queue.length;
  }
}
```

### 离线/在线切换处理

```typescript
class SyncManager {
  private networkMonitor: NetworkMonitor;
  private offlineQueue: OfflineQueue;

  constructor() {
    this.networkMonitor = new NetworkMonitor();
    this.offlineQueue = new OfflineQueue();
    
    this.networkMonitor.onStatusChange((online) => {
      if (online) {
        this.handleOnline();
      } else {
        this.handleOffline();
      }
    });
  }

  async handleOffline(): Promise<void> {
    console.log('进入离线模式');
    
    // 1. 停止自动同步
    this.stopAutoSync();
    
    // 2. 标记为离线状态
    await this.updateSyncStatus({
      syncMode: 'offline',
      connectionStatus: 'disconnected'
    });
    
    // 3. 保存当前同步队列到离线队列
    const queue = await this.getSyncQueue();
    for (const item of queue) {
      if (item.status === 'pending') {
        await this.offlineQueue.enqueue(item);
      }
    }
    
    // 4. 清空同步队列
    await this.clearSyncQueue();
    
    this.emit('offline_mode');
  }

  async handleOnline(): Promise<void> {
    console.log('进入在线模式');
    
    // 1. 恢复连接
    if (this.connectionState === SyncConnectionState.DISCONNECTED) {
      await this.connect();
    }
    
    // 2. 标记为在线状态
    await this.updateSyncStatus({
      syncMode: 'realtime',
      connectionStatus: 'connected'
    });
    
    // 3. 处理离线队列
    await this.processOfflineQueue();
    
    // 4. 启动自动同步
    this.startAutoSync();
    
    this.emit('online_mode');
  }

  private async processOfflineQueue(): Promise<void> {
    while (this.offlineQueue.size() > 0) {
      const item = await this.offlineQueue.dequeue();
      if (!item) break;
      
      try {
        await this.syncOperation(item);
      } catch (error) {
        console.error('离线队列项同步失败:', error);
        await this.offlineQueue.enqueue(item);
        break;
      }
    }
  }

  private async syncOperation(item: SyncQueueItem): Promise<void> {
    // 添加到同步队列
    await this.addToSyncQueue(item);
    
    // 执行同步
    await this.sync();
  }
}
```

---

## 冲突检测与解决

### 版本号检测机制

```typescript
class ConflictDetector {
  async detectConflict(operation: SyncOperation, currentEntity: any): Promise<Conflict | null> {
    const { operation_type, entity_type, entity_id, data, before_version } = operation;
    
    // 1. 检查版本号
    if (before_version !== undefined && currentEntity.version !== before_version) {
      return {
        conflict_id: generateId(),
        conflict_type: ConflictType.VERSION,
        entity_type,
        entity_id,
        server_data: currentEntity,
        client_data: data,
        server_version: currentEntity.version,
        client_version: before_version,
        conflict_fields: [],
        timestamp: Date.now()
      };
    }
    
    // 2. 检查内容哈希
    const clientHash = this.computeContentHash(data);
    if (clientHash === currentEntity.content_hash) {
      // 内容相同，无冲突
      return null;
    }
    
    // 3. 检测冲突字段
    const conflictFields = this.detectConflictFields(data, currentEntity);
    
    if (conflictFields.length === 0) {
      return null;
    }
    
    return {
      conflict_id: generateId(),
      conflict_type: ConflictType.CONTENT,
      entity_type,
      entity_id,
      server_data: currentEntity,
      client_data: data,
      conflict_fields,
      timestamp: Date.now()
    };
  }

  private detectConflictFields(clientData: any, serverData: any): string[] {
    const conflicts: string[] = [];
    
    for (const key of Object.keys(clientData)) {
      if (key === 'version' || key === 'content_hash' || key === 'id') {
        continue;
      }
      
      if (clientData[key] !== serverData[key]) {
        conflicts.push(key);
      }
    }
    
    return conflicts;
  }

  private computeContentHash(data: any): string {
    const dataWithoutMeta = { ...data };
    delete dataWithoutMeta.version;
    delete dataWithoutMeta.content_hash;
    delete dataWithoutMeta.updated_at;
    
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(dataWithoutMeta))
      .digest('hex');
  }
}
```

### 冲突解决策略

```typescript
enum ConflictResolutionStrategy {
  SERVER_WINS = 'server_wins',    // 使用服务器版本
  CLIENT_WINS = 'client_wins',    // 使用客户端版本
  LATEST_WINS = 'latest_wins',     // 基于时间戳，最新的版本胜出
  MERGE = 'merge',                 // 合并版本
  MANUAL = 'manual'                // 手动解决
}

class ConflictResolver {
  async resolveConflict(
    conflict: Conflict,
    strategy: ConflictResolutionStrategy,
    resolvedData?: any
  ): Promise<any> {
    switch (strategy) {
      case ConflictResolutionStrategy.SERVER_WINS:
        return this.serverWins(conflict);
      
      case ConflictResolutionStrategy.CLIENT_WINS:
        return this.clientWins(conflict);
      
      case ConflictResolutionStrategy.LATEST_WINS:
        return this.latestWins(conflict);
      
      case ConflictResolutionStrategy.MERGE:
        return this.merge(conflict, resolvedData);
      
      case ConflictResolutionStrategy.MANUAL:
        return this.manual(conflict, resolvedData);
      
      default:
        throw new Error(`未知的冲突解决策略: ${strategy}`);
    }
  }

  private serverWins(conflict: Conflict): any {
    return conflict.server_data;
  }

  private clientWins(conflict: Conflict): any {
    return conflict.client_data;
  }

  private latestWins(conflict: Conflict): any {
    const serverTime = new Date(conflict.server_data.updated_at).getTime();
    const clientTime = new Date(conflict.client_data.updated_at || Date.now()).getTime();
    
    return serverTime > clientTime ? conflict.server_data : conflict.client_data;
  }

  private merge(conflict: Conflict, resolvedData: any): any {
    if (!resolvedData) {
      throw new Error('合并策略需要提供resolvedData');
    }
    
    return {
      ...conflict.server_data,
      ...resolvedData,
      version: conflict.server_data.version + 1
    };
  }

  private manual(conflict: Conflict, resolvedData: any): any {
    if (!resolvedData) {
      throw new Error('手动解决需要提供resolvedData');
    }
    
    return resolvedData;
  }
}
```

### 冲突处理流程

```typescript
class SyncManager {
  private conflictDetector = new ConflictDetector();
  private conflictResolver = new ConflictResolver();

  async handleConflict(conflict: Conflict): Promise<void> {
    // 1. 保存冲突到缓存
    await this.cache.set(`conflict:${conflict.conflict_id}`, conflict);
    
    // 2. 添加到冲突列表
    await this.addConflictItem(conflict);
    
    // 3. 根据配置自动或手动解决
    const strategy = this.config.defaultConflictStrategy;
    
    if (strategy === ConflictResolutionStrategy.MANUAL) {
      this.emit('conflict', conflict);
    } else {
      try {
        const resolved = await this.conflictResolver.resolveConflict(conflict, strategy);
        await this.applyResolvedConflict(conflict, resolved);
      } catch (error) {
        console.error('自动解决冲突失败:', error);
        this.emit('conflict', conflict);
      }
    }
  }

  async applyResolvedConflict(conflict: Conflict, resolvedData: any): Promise<void> {
    // 1. 更新缓存
    await this.cache.set(`${conflict.entity_type}:${conflict.entity_id}`, resolvedData);
    
    // 2. 发送解决请求
    await this.wsClient.send({
      type: 'resolve_conflict',
      conflict_id: conflict.conflict_id,
      resolution: {
        strategy: this.config.defaultConflictStrategy,
        resolved_data: resolvedData
      }
    });
    
    // 3. 更新冲突状态
    await this.updateConflictStatus(conflict.conflict_id, 'resolved');
    
    // 4. 移除冲突项
    await this.removeConflictItem(conflict.conflict_id);
  }

  async manualResolveConflict(
    conflictId: string,
    strategy: ConflictResolutionStrategy,
    resolvedData: any
  ): Promise<void> {
    const conflict = await this.cache.get(`conflict:${conflictId}`);
    if (!conflict) throw new Error('冲突不存在');
    
    const resolved = await this.conflictResolver.resolveConflict(
      conflict.data,
      strategy,
      resolvedData
    );
    
    await this.applyResolvedConflict(conflict.data, resolved);
  }
}
```

---

## 三层缓存一致性保障

### 跨层级一致性检查

```typescript
class CacheConsistencyChecker {
  async checkConsistency(cache: HybridCache): Promise<ConsistencyReport> {
    const report: ConsistencyReport = {
      consistent: true,
      issues: []
    };
    
    // 1. 检查IndexedDB和localStorage的同步状态
    const keys = await cache.keys();
    
    for (const key of keys) {
      const memoryItem = await cache.getFromMemory(key);
      const indexedDBItem = await cache.getFromIndexedDB(key);
      
      if (memoryItem && indexedDBItem) {
        // 比对版本号
        if (memoryItem.version !== indexedDBItem.version) {
          report.issues.push({
            type: 'version_mismatch',
            key,
            memoryVersion: memoryItem.version,
            indexedDBVersion: indexedDBItem.version
          });
          report.consistent = false;
        }
        
        // 比对内容哈希
        if (memoryItem.content_hash !== indexedDBItem.content_hash) {
          report.issues.push({
            type: 'content_mismatch',
            key,
            memoryHash: memoryItem.content_hash,
            indexedDBHash: indexedDBItem.content_hash
          });
          report.consistent = false;
        }
      }
    }
    
    return report;
  }

  async fixInconsistency(cache: HybridCache, report: ConsistencyReport): Promise<void> {
    for (const issue of report.issues) {
      switch (issue.type) {
        case 'version_mismatch':
        case 'content_mismatch':
          // 以IndexedDB为准，更新内存缓存
          const indexedDBItem = await cache.getFromIndexedDB(issue.key);
          if (indexedDBItem) {
            await cache.setToMemory(issue.key, indexedDBItem.data, {
              version: indexedDBItem.version,
              content_hash: indexedDBItem.content_hash
            });
          }
          break;
      }
    }
  }
}
```

### 写一致性保障

```typescript
class HybridCache {
  async set<T>(key: string, data: T, options?: CacheOptions): Promise<void> {
    const version = options?.version || await this.getNextVersion(key);
    const contentHash = this.computeContentHash(data);
    
    const cacheData: CacheData<T> = {
      data,
      key,
      version,
      content_hash,
      timestamp: Date.now(),
      expiresAt: options?.ttl ? Date.now() + options.ttl : undefined,
      tags: options?.tags,
      metadata: options?.metadata
    };
    
    // 原子写入所有层级
    const promises = [
      this.memoryCache.set(key, cacheData),
      this.indexedDBCache.set(key, cacheData)
    ];
    
    if (this.isMetadataKey(key)) {
      promises.push(this.localStorageCache.set(key, cacheData));
    }
    
    await Promise.all(promises);
    
    this.emit({ type: 'set', key, data, timestamp: Date.now() });
  }

  private computeContentHash(data: any): string {
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex');
  }

  private async getNextVersion(key: string): Promise<number> {
    const current = await this.get(key);
    return current ? (current.version || 0) + 1 : 1;
  }
}
```

---

## 错误处理和重试机制

### 错误分类

```typescript
enum SyncErrorType {
  NETWORK_ERROR = 'network_error',           // 网络错误
  AUTH_ERROR = 'auth_error',               // 认证错误
  VALIDATION_ERROR = 'validation_error',     // 验证错误
  CONFLICT_ERROR = 'conflict_error',       // 冲突错误
  TIMEOUT_ERROR = 'timeout_error',         // 超时错误
  UNKNOWN_ERROR = 'unknown_error'          // 未知错误
}

class SyncError extends Error {
  constructor(
    public type: SyncErrorType,
    message: string,
    public retryable: boolean = true,
    public originalError?: Error
  ) {
    super(message);
    this.name = 'SyncError';
  }
}
```

### 重试机制

```typescript
class RetryManager {
  private readonly DEFAULT_MAX_RETRIES = 3;
  private readonly DEFAULT_RETRY_DELAY = 5000;
  private readonly EXPONENTIAL_BACKOFF = true;

  async retry<T>(
    fn: () => Promise<T>,
    options?: {
      maxRetries?: number;
      retryDelay?: number;
      exponentialBackoff?: boolean;
      onRetry?: (attempt: number, error: Error) => void;
    }
  ): Promise<T> {
    const maxRetries = options?.maxRetries ?? this.DEFAULT_MAX_RETRIES;
    const retryDelay = options?.retryDelay ?? this.DEFAULT_RETRY_DELAY;
    const exponentialBackoff = options?.exponentialBackoff ?? this.EXPONENTIAL_BACKOFF;

    let lastError: Error;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;
        
        if (attempt < maxRetries) {
          const delay = exponentialBackoff 
            ? retryDelay * Math.pow(2, attempt)
            : retryDelay;
          
          console.warn(`操作失败，${delay}ms后重试 (${attempt + 1}/${maxRetries}):`, error);
          
          if (options?.onRetry) {
            options.onRetry(attempt + 1, lastError);
          }
          
          await this.delay(delay);
        }
      }
    }

    throw lastError;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 错误处理流程

```typescript
class SyncManager {
  private retryManager = new RetryManager();

  async sync(): Promise<void> {
    try {
      await this.retryManager.retry(
        async () => {
          const request = await this.buildSyncRequest();
          const response = await this.sendSyncRequest(request);
          await this.processSyncResponse(response);
        },
        {
          maxRetries: this.config.maxRetries,
          retryDelay: this.config.retryDelay,
          exponentialBackoff: true,
          onRetry: (attempt, error) => {
            this.emit('sync_retry', { attempt, error });
          }
        }
      );
    } catch (error) {
      await this.handleError(error);
    }
  }

  private async handleError(error: any): Promise<void> {
    const syncError = this.classifyError(error);
    
    switch (syncError.type) {
      case SyncErrorType.NETWORK_ERROR:
        this.emit('network_error', syncError);
        this.handleNetworkError();
        break;
      
      case SyncErrorType.AUTH_ERROR:
        this.emit('auth_error', syncError);
        this.handleAuthError();
        break;
      
      case SyncErrorType.CONFLICT_ERROR:
        this.emit('conflict_error', syncError);
        break;
      
      case SyncErrorType.TIMEOUT_ERROR:
        this.emit('timeout_error', syncError);
        break;
      
      default:
        this.emit('unknown_error', syncError);
    }
    
    this.emit('sync_error', syncError);
  }

  private classifyError(error: any): SyncError {
    if (error.code === 'NETWORK_ERROR' || !navigator.onLine) {
      return new SyncError(SyncErrorType.NETWORK_ERROR, error.message, true, error);
    }
    
    if (error.status === 401 || error.status === 403) {
      return new SyncError(SyncErrorType.AUTH_ERROR, error.message, false, error);
    }
    
    if (error.status === 409) {
      return new SyncError(SyncErrorType.CONFLICT_ERROR, error.message, false, error);
    }
    
    if (error.name === 'TimeoutError') {
      return new SyncError(SyncErrorType.TIMEOUT_ERROR, error.message, true, error);
    }
    
    return new SyncError(SyncErrorType.UNKNOWN_ERROR, error.message, false, error);
  }

  private handleNetworkError(): void {
    if (navigator.onLine) {
      console.log('网络连接正常，重试...');
      this.startAutoSync();
    } else {
      console.log('网络已断开，进入离线模式');
      this.handleOffline();
    }
  }

  private handleAuthError(): void {
    console.log('认证失败，需要重新登录');
    this.emit('require_reauth');
  }
}
```

---

## 版本历史

- **v1.0.0** (2024-01-10): 初始版本，定义完整的前后端集成方案
